<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://pengdake.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://pengdake.github.io/" rel="alternate" type="text/html" /><updated>2025-07-09T06:52:15+00:00</updated><id>https://pengdake.github.io/feed.xml</id><title type="html">pdk的日常记录</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">linux_fstab_set</title><link href="https://pengdake.github.io/2025/07/09/linux_boot_set/" rel="alternate" type="text/html" title="linux_fstab_set" /><published>2025-07-09T00:00:00+00:00</published><updated>2025-07-09T00:00:00+00:00</updated><id>https://pengdake.github.io/2025/07/09/linux_boot_set</id><content type="html" xml:base="https://pengdake.github.io/2025/07/09/linux_boot_set/"><![CDATA[<h1 id="linux分区挂载设置">linux分区挂载设置</h1>

<h2 id="背景">背景</h2>
<p>家里树莓派通过usb挂载的磁盘存储，有时会插拔存储对应的usb接口，磁盘分区名称可能会发生变化，从而导致开机引导失败，为了避免此种情况，需要在/etc/fstab中设置基于uuid的挂载</p>

<h2 id="uuid">uuid</h2>
<p>这里的uuid是唯一标识磁盘分区的标识符，是 Linux 中识别磁盘设备最推荐的方式之一，尤其适用于多磁盘、USB 接口不固定的情况。在格式化分区的时候生成，除非格式化或通过其它方式人为改动，否则不会变化</p>

<h2 id="操作示例">操作示例</h2>
<p>获取uuid</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo blkid
/dev/sda1: LABEL_FATBOOT="boot" LABEL="boot" UUID="54E3-79CE" TYPE="vfat" PARTUUID="d5f8932e-01"
/dev/sda2: LABEL="rootfs" UUID="c6dd3b94-a789-4d57-9080-1472f721804b" TYPE="ext4" PARTUUID="d5f8932e-02"
</code></pre></div></div>
<p>更新fstab</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat /etc/fstab
proc            /proc           proc    defaults          0       0
/dev/sda1  /boot           vfat    defaults          0       2
/dev/sda2  /           ext4    defaults,noatime          0       1

sudo sed -i 's|^/dev/sda1|UUID=54E3-79CE|g' /etc/fstab
sudo sed -i 's|^/dev/sda2|UUID=c6dd3b94-a789-4d57-9080-1472f721804b|g' /etc/fstab
</code></pre></div></div>]]></content><author><name></name></author><category term="linux" /><category term="linux" /><category term="fstab" /><summary type="html"><![CDATA[linux分区挂载设置]]></summary></entry><entry><title type="html">docker_buildx_info</title><link href="https://pengdake.github.io/2025/07/08/docker_buildx/" rel="alternate" type="text/html" title="docker_buildx_info" /><published>2025-07-08T00:00:00+00:00</published><updated>2025-07-08T00:00:00+00:00</updated><id>https://pengdake.github.io/2025/07/08/docker_buildx</id><content type="html" xml:base="https://pengdake.github.io/2025/07/08/docker_buildx/"><![CDATA[<h1 id="使用docker_buildx构建跨平台容器镜像">使用docker_buildx构建跨平台容器镜像</h1>

<h2 id="背景">背景</h2>
<p>最近用旧的笔记本和树莓派4b搭建了一个两节点的docker swarm环境，由于笔记本和树莓派的cpu架构不同，分别是amd64和arm的，而为了实现部署应用的容器能够在所有节点自由调度，需要保证节点获取与其处理器架构对应的容器镜像。因此需要利用docker buildx同时制作跨平台的容器镜像</p>

<h2 id="安装">安装</h2>
<p>qemu模拟器安装启用，用于非本机架构的镜像构建</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --rm --privileged tonistiigi/binfmt --install all
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>latest: Pulling from tonistiigi/binfmt
07872a4bb80c: Pull complete
da5179bfe27f: Pull complete
Digest: sha256:1b804311fe87047a4c96d38b4b3ef6f62fca8cd125265917a9e3dc3c996c39e6
Status: Downloaded newer image for tonistiigi/binfmt:latest
installing: mips64le OK
installing: amd64 OK
installing: 386 OK
installing: s390x OK
installing: ppc64le OK
installing: riscv64 OK
installing: mips64 OK
installing: loong64 OK
{
  "supported": [
    "linux/arm64",
    "linux/amd64",
    "linux/amd64/v2",
    "linux/riscv64",
    "linux/ppc64le",
    "linux/s390x",
    "linux/386",
    "linux/mips64le",
    "linux/mips64",
    "linux/loong64",
    "linux/arm/v7",
    "linux/arm/v6"
  ],
  "emulators": [
    "qemu-i386",
    "qemu-loongarch64",
    "qemu-mips64",
    "qemu-mips64el",
    "qemu-ppc64le",
    "qemu-riscv64",
    "qemu-s390x",
    "qemu-x86_64"
  ]
}

</code></pre></div></div>

<p>docker buildx在版本19.03后的docker已经内置了，只是需要执行以下命令创建构建器的容器
创建buildx</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker buildx create --use --name multiarch 
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#注：如果上传的本地仓库为http,则需要按以下步骤初始化
cat &lt;&lt;EOF &gt; buildkitd.toml
[registry."192.168.31.98:5000"]
  http = true
  insecure = true
EOF
docker buildx create \
  --name multiarch \
  --config ./buildkitd.toml \
  --use
</code></pre></div></div>
<p>运行buildx</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker buildx inspect --bootstrap
</code></pre></div></div>
<p>查看</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker buildx inspect multiarch 
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Name:          multiarch
Driver:        docker-container
Last Activity: 2025-07-08 04:24:18 +0000 UTC

Nodes:
Name:                  multiarch0
Endpoint:              unix:///var/run/docker.sock
Status:                running
BuildKit daemon flags: --allow-insecure-entitlement=network.host
BuildKit version:      v0.22.0
Platforms:             linux/arm64, linux/arm/v7, linux/arm/v6
Labels:
 org.mobyproject.buildkit.worker.executor:         oci
 org.mobyproject.buildkit.worker.hostname:         9929657bf10d
 org.mobyproject.buildkit.worker.network:          host
 org.mobyproject.buildkit.worker.oci.process-mode: sandbox
 org.mobyproject.buildkit.worker.selinux.enabled:  false
 org.mobyproject.buildkit.worker.snapshotter:      overlayfs
GC Policy rule#0:
 All:           false
 Filters:       type==source.local,type==exec.cachemount,type==source.git.checkout
 Keep Duration: 48h0m0s
GC Policy rule#1:
 All:           false
 Keep Duration: 1440h0m0s
 Keep Bytes:    9.313GiB
GC Policy rule#2:
 All:        false
 Keep Bytes: 9.313GiB
GC Policy rule#3:
 All:        true
 Keep Bytes: 9.313GiB

</code></pre></div></div>

<h2 id="制作镜像示例">制作镜像示例</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 制作amd64和arm64架构的镜像，并上传到本地仓库，注意要指定builder为上一步创建的multiarch
docker buildx build --builder multiarch --platform linux/amd64,linux/arm64 -t 192.168.31.98:5000/go-video --push .
</code></pre></div></div>

<h2 id="扩展">扩展</h2>
<p>如果是已有现成的异构镜像，可通过创建manifest的方式来实现
假如本地仓库存在以下两个异构镜像</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># arm64
192.168.31.98:5000/nginx:1.29.0-arm64
# amd64
192.168.31.98:5000/nginx:1.29.0-amd64
</code></pre></div></div>
<p>创建对应的manifest，并上传到本地仓库</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker manifest create --insecure   192.168.31.98:5000/nginx:1.29.0 --amend 192.168.31.98:5000/nginx:1.29.0-arm64 --amend  192.168.31.98:5000/nginx:1.29.0-amd64
docker manifest push --insecure 192.168.31.98:5000/nginx:1.29.0
</code></pre></div></div>
<p>验证镜像的manifest已包含两种架构</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker manifest inspect --insecure 192.168.31.98:5000/nginx:1.29.0
{
   "schemaVersion": 2,
   "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",
   "manifests": [
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1778,
         "digest": "sha256:ccde53834eab53e85b35526a647cdb714ea4521b1ddf5a07b5c8787298d13087",
         "platform": {
            "architecture": "amd64",
            "os": "linux"
         }
      },
      {
         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
         "size": 1778,
         "digest": "sha256:a27d6dc7e214fa0a360a2e3dbe1aa36b7ab00b76915df7a1d5feb6556856f700",
         "platform": {
            "architecture": "arm64",
            "os": "linux",
            "variant": "v8"
         }
      }
   ]
}

</code></pre></div></div>]]></content><author><name></name></author><category term="docker" /><category term="docker" /><category term="image" /><category term="docker_swarm" /><summary type="html"><![CDATA[使用docker_buildx构建跨平台容器镜像]]></summary></entry><entry><title type="html">ssh_load_k8s_env</title><link href="https://pengdake.github.io/2020/01/30/ssh_load_k8s_env/" rel="alternate" type="text/html" title="ssh_load_k8s_env" /><published>2020-01-30T00:00:00+00:00</published><updated>2020-01-30T00:00:00+00:00</updated><id>https://pengdake.github.io/2020/01/30/ssh_load_k8s_env</id><content type="html" xml:base="https://pengdake.github.io/2020/01/30/ssh_load_k8s_env/"><![CDATA[<h1 id="ssh远程登陆加载环境变量">ssh远程登陆加载环境变量</h1>

<h2 id="背景">背景</h2>
<ul>
  <li>k8s新建pod时，为了满足某些pod访问当前namespace下svc的需要，即要pod具有服务发现的能力，默认会将当前namespace下面的svc信息以环境变量的形式注入到容器当中，当前namespace下如果存在过多的svc，注入的环境变量的数目将变得很大。<a href="https://kubernetes.io/docs/concepts/services-networking/connect-applications-service/">文档链接</a></li>
  <li>ssh远程登陆会清理环境变量，只会根据bash模式加载/etc/profile, ~/.bashrc等文件中的环境变量。关于不同bash模式加载哪些文件，可以通过man bash查看，这里就不在细说。</li>
</ul>

<h2 id="问题">问题</h2>
<p>最近遇到个需求，需要在ssh远程登陆时，能够自动加载我们在k8s资源文件中自定义的容器环境变量，这个实现很简单，只需要在容器启动时，将env命令输出的环境变量转储到/etc/profile.d/k8s_env.sh，ssh远程登陆会自动加载这里面的环境变量。但是由于当前pod所在namespaces中存在过多的svc资源，并且当前pod不需要与其它svc通信，因此传入了许多不必要的环境变量，有没有什么办法过滤掉这些不需要的环境变量呢？</p>

<h2 id="如何避免过多关于k8s的环境变量">如何避免过多关于k8s的环境变量</h2>
<p>这个目前可以通过在pod.spec中添加enableServcieLinks变量进行控制，当设置为false时，会禁止当前namespace下的svc信息以环境变量的形式注入到pod中。需要注意的是该变量仅支持1.13及以后的版本。</p>

<h2 id="延伸">延伸</h2>
<h3 id="服务发现的替代品">服务发现的替代品</h3>
<p>k8s原生支持两种服务发现的方式，一种就是上面所说的通过环境变量，这种方式目前存在一些问题，包括pod所依赖服务必须先于pod创建，注入环境变量过多可能会与自己定义的环境变量名重合导致错误，以及无法根据当前namespace下svc资源情况进行动态更新。因此官方推荐的方式也就是第二种方式，就是通过dns来实现服务发现，这个可以借助插件来实现，比如coredns。</p>
<h3 id="enableservicelinks的具体作用">enableServiceLinks的具体作用</h3>
<p>目前enableServiceLinks默认为true,当设置为false时，当前namespace下的svc信息不会以环境变量的形式注入到pod,但是需要注意的是master namespace(默认为default)下的kubernetes svc信息会以环境变量的形式注入到pod中。<a href="https://github.com/kubernetes/kubernetes/pull/68754">具体参考</a></p>]]></content><author><name></name></author><category term="k8s" /><category term="k8s" /><category term="ssh" /><category term="优化" /><summary type="html"><![CDATA[ssh远程登陆加载环境变量]]></summary></entry></feed>